{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Fast \u00b6 Fast is a \"Find AST\" tool to help you search in the code abstract syntax tree. Ruby allow us to do the same thing in a few ways then it's hard to check how the code is written. Using the AST will be easier than try to cover the multiple ways we can write the same code. You can define a string like: %|| or '' or \"\" but they will have the same AST representation. AST representation \u00b6 Each detail of the ruby syntax have a equivalent identifier and some content. The content can be another expression or a final value. Fast uses parser gem behind the scenes to parse the code into nodes. First get familiar with parser gem and understand how ruby code is represented. When you install parser gem, you will have access to ruby-parse and you can use it with -e to parse an expression directly from the command line. Example: ruby-parse -e 1 It will print the following output: (int 1) And trying a number with decimals: ruby-parse -e 1.1 (float 1) Building a regex that will match decimals and integer looks like something easy and with fast you use a node pattern that reminds the syntax of regular expressions. Syntax for find in AST \u00b6 The current version cover the following elements: () to represent a node search {} is for any matches like union conditions with or operator [] is for all matches like intersect conditions with and operator $ is for capture current expression _ is something not nil nil matches exactly nil ... is a node with children ^ is to get the parent node of an expression ? is for maybe \\1 to use the first previous captured element \"\" surround the value with double quotes to match literal strings The syntax is inspired on RuboCop Node Pattern . Fast.match? \u00b6 match? is the most granular function that tries to compare a node with an expression. It returns true or false and some node captures case it find something. Let's start with a simple integer in Ruby: 1 The AST can be represented with the following expression: (int 1) The ast representation holds node type and children . Let's build a method s to represent Parser::AST::Node with a #type and #children . def s ( type , * children ) Parser :: AST :: Node . new ( type , children ) end A local variable assignment: value = 42 Can be represented with: ast = s ( :lvasgn , :value , s ( :int , 42 )) Now, lets find local variable named value with an value 42 : Fast . match? ( ast , '(lvasgn value (int 42))' ) # true Lets abstract a bit and allow some integer value using _ as a shortcut: Fast . match? ( ast , '(lvasgn value (int _))' ) # true Lets abstract more and allow float or integer: Fast . match? ( ast , '(lvasgn value ({float int} _))' ) # true Or combine multiple assertions using [] to join conditions: Fast . match? ( ast , '(lvasgn value ([!str !hash !array] _))' ) # true Matches all local variables not string and not hash and not array. We can match \"a node with children\" using ... : Fast . match? ( ast , '(lvasgn value ...)' ) # true You can use $ to capture a node: Fast . match? ( ast , '(lvasgn value $...)' ) # => [s(:int, 42)] Or match whatever local variable assignment combining both _ and ... : Fast . match? ( ast , '(lvasgn _ ...)' ) # true You can also use captures in any levels you want: Fast . match? ( ast , '(lvasgn $_ $...)' ) # [:value, s(:int, 42)] Keep in mind that _ means something not nil and ... means a node with children. Then, if do you get a method declared: def my_method call_other_method end It will be represented with the following structure: ast = s ( :def , :my_method , s ( :args ), s ( :send , nil , :call_other_method )) Keep an eye on the node (args) . Then you know you can't use ... but you can match with (_) to match with such case. Let's test a few other examples. You can go deeply with the arrays. Let's suppose we have a hardcore call to a.b.c.d and the following AST represents it: ast = s ( :send , s ( :send , s ( :send , s ( :send , nil , :a ), :b ), :c ), :d ) You can search using sub-arrays with pure values , or shortcuts or procs : Fast . match? ( ast , [ :send , [ :send , '...' ] , :d ] ) # => true Fast . match? ( ast , [ :send , [ :send , '...' ] , :c ] ) # => false Fast . match? ( ast , [ :send , [ :send , [ :send , '...' ] , :c ] , :d ] ) # => true Shortcuts like ... and _ are just literals for procs. Then you can use procs directly too: Fast . match? ( ast , [ :send , [ -> ( node ) { node . type == :send }, [ :send , '...' ] , :c ] , :d ] ) # => true And also work with expressions: Fast . match? ( ast , '(send (send (send (send nil $_) $_) $_) $_)' ) # => [:a, :b, :c, :d] If something does not work you can debug with a block: Fast . debug { Fast . match? ( s ( :int , 1 ), [ :int , 1 ] ) } It will output each comparison to stdout: int == (int 1) # => true 1 == 1 # => true Use previous captures in search \u00b6 Imagine you're looking for a method that is just delegating something to another method, like: def name person . name end This can be represented as the following AST: (def :name (args) (send (send nil :person) :name)) Then, let's build a search for methods that calls an attribute with the same name: Fast . match? ( ast , '(def $_ ... (send (send nil _) \\1))' ) # => [:name] Fast.search \u00b6 Search allows you to go deeply in the AST, collecting nodes that matches with the expression. It also returns captures if they exist. Fast . search ( code ( 'a = 1' ), '(int _)' ) # => s(:int, 1) If you use captures, it returns the node and the captures respectively: Fast . search ( code ( 'a = 1' ), '(int $_)' ) # => [s(:int, 1), 1] Fast.capture \u00b6 To pick just the captures and ignore the nodes, use Fast.capture : Fast . capture ( code ( 'a = 1' ), '(int $_)' ) # => 1 Fast.replace \u00b6 And if I want to refactor a code and use delegate <attribute>, to: <object> , try with replace: Fast . replace ast , '(def $_ ... (send (send nil $_) \\1))' , -> ( node , captures ) { attribute , object = captures replace ( node . location . expression , \"delegate : #{ attribute } , to: : #{ object } \" ) } Fast.replace_file \u00b6 Now let's imagine we have real files like sample.rb with the following code: def good_bye message = [ \"good\" , \"bye\" ] puts message . join ( ' ' ) end And we decide to remove the message variable and put it inline with the puts . Basically, we need to find the local variable assignment, store the value in memory. Remove the assignment expression and use the value where the variable is being called. assignment = nil Fast . replace_file ( 'sample.rb' , '({ lvasgn lvar } message )' , -> ( node , _ ) { if node . type == :lvasgn assignment = node . children . last remove ( node . location . expression ) elsif node . type == :lvar replace ( node . location . expression , assignment . location . expression . source ) end } ) Fast.ast_from_File(file) \u00b6 This method parses the code and load into a AST representation. Fast . ast_from_file ( 'sample.rb' ) Fast.search_file \u00b6 You can use search_file and pass the path for search for expressions inside files. Fast . search_file ( 'file.rb' , expression ) It's simple combination of Fast.ast_from_file with Fast.search . Fast.ruby_files_from(arguments) \u00b6 You'll be probably looking for multiple ruby files, then this method fetches all internal .rb files Fast . ruby_files_from ( [ 'lib' ] ) # => [\"lib/fast.rb\"] Command line \u00b6 It will also inject a executable named fast and you can use it to search and find code using the concept: $ fast '(def match?)' lib/fast.rb Use -d or --debug for enable debug mode. Use --ast to output the AST instead of the original code Use --pry to jump debugging the first result with pry Use -c to search from code example Use -s to search similar code $ fast '(block (send nil it))' spec --pry And inside pry session, you can use result as the first result or results to use all occurrences found. results . map { | e | e . children [ 0 ]. children [ 2 ] } # => [s(:str, \"parses ... as Find\"), # s(:str, \"parses $ as Capture\"), # s(:str, \"parses quoted values as strings\"), # s(:str, \"parses {} as Any\"), # s(:str, \"parses [] as All\"), ...] Getting all it blocks without description: $ fast '(block (send nil it (nil)) (args ) (!str)) ) )' spec # spec/fast_spec.rb:166 it { expect ( described_class ) . to be_match ( s ( :int , 1 ), '(...)' ) } # spec/fast_spec.rb:167 it { expect ( described_class ) . to be_match ( s ( :int , 1 ), '(_ _)' ) } # spec/fast_spec.rb:168 it { expect ( described_class ) . to be_match ( code [ '\"string\"' ] , '(str \"string\")' ) } # ... more results Fast.experiment \u00b6 You can define experiments and build experimental research to improve some code in an automated way. Let's create an experiment to try to remove before or after blocks and run specs. If the spec pass without need the hook, the hook is useless. Fast . experiment ( \"RSpec/RemoveUselessBeforeAfterHook\" ) do lookup 'spec' search \"(block (send nil {before after}))\" edit { | node | remove ( node . loc . expression ) } policy { | new_file | system ( \"bin/spring rspec --fail-fast #{ new_file } \" ) } end In the lookup you can pass files or folders. The search contains the expression you want to match With edit block you can apply the code change And the policy is executed to check if the current change is valuable If the file contains multiple before or after blocks, each removal will occur independently and the successfull removals will be combined as a secondary change. The process repeates until find all possible combinations. See more examples in experiments folder. To run multiple experiments, use fast-experiment runner: fast-experiment <experiment-names> <files-or-folders> You can limit experiments or file escope: fast-experiment RSpec/RemoveUselessBeforeAfterHook spec/models/**/*_spec.rb","title":"Introduction"},{"location":"#fast","text":"Fast is a \"Find AST\" tool to help you search in the code abstract syntax tree. Ruby allow us to do the same thing in a few ways then it's hard to check how the code is written. Using the AST will be easier than try to cover the multiple ways we can write the same code. You can define a string like: %|| or '' or \"\" but they will have the same AST representation.","title":"Fast"},{"location":"#ast-representation","text":"Each detail of the ruby syntax have a equivalent identifier and some content. The content can be another expression or a final value. Fast uses parser gem behind the scenes to parse the code into nodes. First get familiar with parser gem and understand how ruby code is represented. When you install parser gem, you will have access to ruby-parse and you can use it with -e to parse an expression directly from the command line. Example: ruby-parse -e 1 It will print the following output: (int 1) And trying a number with decimals: ruby-parse -e 1.1 (float 1) Building a regex that will match decimals and integer looks like something easy and with fast you use a node pattern that reminds the syntax of regular expressions.","title":"AST representation"},{"location":"#syntax-for-find-in-ast","text":"The current version cover the following elements: () to represent a node search {} is for any matches like union conditions with or operator [] is for all matches like intersect conditions with and operator $ is for capture current expression _ is something not nil nil matches exactly nil ... is a node with children ^ is to get the parent node of an expression ? is for maybe \\1 to use the first previous captured element \"\" surround the value with double quotes to match literal strings The syntax is inspired on RuboCop Node Pattern .","title":"Syntax for find in AST"},{"location":"#fastmatch","text":"match? is the most granular function that tries to compare a node with an expression. It returns true or false and some node captures case it find something. Let's start with a simple integer in Ruby: 1 The AST can be represented with the following expression: (int 1) The ast representation holds node type and children . Let's build a method s to represent Parser::AST::Node with a #type and #children . def s ( type , * children ) Parser :: AST :: Node . new ( type , children ) end A local variable assignment: value = 42 Can be represented with: ast = s ( :lvasgn , :value , s ( :int , 42 )) Now, lets find local variable named value with an value 42 : Fast . match? ( ast , '(lvasgn value (int 42))' ) # true Lets abstract a bit and allow some integer value using _ as a shortcut: Fast . match? ( ast , '(lvasgn value (int _))' ) # true Lets abstract more and allow float or integer: Fast . match? ( ast , '(lvasgn value ({float int} _))' ) # true Or combine multiple assertions using [] to join conditions: Fast . match? ( ast , '(lvasgn value ([!str !hash !array] _))' ) # true Matches all local variables not string and not hash and not array. We can match \"a node with children\" using ... : Fast . match? ( ast , '(lvasgn value ...)' ) # true You can use $ to capture a node: Fast . match? ( ast , '(lvasgn value $...)' ) # => [s(:int, 42)] Or match whatever local variable assignment combining both _ and ... : Fast . match? ( ast , '(lvasgn _ ...)' ) # true You can also use captures in any levels you want: Fast . match? ( ast , '(lvasgn $_ $...)' ) # [:value, s(:int, 42)] Keep in mind that _ means something not nil and ... means a node with children. Then, if do you get a method declared: def my_method call_other_method end It will be represented with the following structure: ast = s ( :def , :my_method , s ( :args ), s ( :send , nil , :call_other_method )) Keep an eye on the node (args) . Then you know you can't use ... but you can match with (_) to match with such case. Let's test a few other examples. You can go deeply with the arrays. Let's suppose we have a hardcore call to a.b.c.d and the following AST represents it: ast = s ( :send , s ( :send , s ( :send , s ( :send , nil , :a ), :b ), :c ), :d ) You can search using sub-arrays with pure values , or shortcuts or procs : Fast . match? ( ast , [ :send , [ :send , '...' ] , :d ] ) # => true Fast . match? ( ast , [ :send , [ :send , '...' ] , :c ] ) # => false Fast . match? ( ast , [ :send , [ :send , [ :send , '...' ] , :c ] , :d ] ) # => true Shortcuts like ... and _ are just literals for procs. Then you can use procs directly too: Fast . match? ( ast , [ :send , [ -> ( node ) { node . type == :send }, [ :send , '...' ] , :c ] , :d ] ) # => true And also work with expressions: Fast . match? ( ast , '(send (send (send (send nil $_) $_) $_) $_)' ) # => [:a, :b, :c, :d] If something does not work you can debug with a block: Fast . debug { Fast . match? ( s ( :int , 1 ), [ :int , 1 ] ) } It will output each comparison to stdout: int == (int 1) # => true 1 == 1 # => true","title":"Fast.match?"},{"location":"#use-previous-captures-in-search","text":"Imagine you're looking for a method that is just delegating something to another method, like: def name person . name end This can be represented as the following AST: (def :name (args) (send (send nil :person) :name)) Then, let's build a search for methods that calls an attribute with the same name: Fast . match? ( ast , '(def $_ ... (send (send nil _) \\1))' ) # => [:name]","title":"Use previous captures in search"},{"location":"#fastsearch","text":"Search allows you to go deeply in the AST, collecting nodes that matches with the expression. It also returns captures if they exist. Fast . search ( code ( 'a = 1' ), '(int _)' ) # => s(:int, 1) If you use captures, it returns the node and the captures respectively: Fast . search ( code ( 'a = 1' ), '(int $_)' ) # => [s(:int, 1), 1]","title":"Fast.search"},{"location":"#fastcapture","text":"To pick just the captures and ignore the nodes, use Fast.capture : Fast . capture ( code ( 'a = 1' ), '(int $_)' ) # => 1","title":"Fast.capture"},{"location":"#fastreplace","text":"And if I want to refactor a code and use delegate <attribute>, to: <object> , try with replace: Fast . replace ast , '(def $_ ... (send (send nil $_) \\1))' , -> ( node , captures ) { attribute , object = captures replace ( node . location . expression , \"delegate : #{ attribute } , to: : #{ object } \" ) }","title":"Fast.replace"},{"location":"#fastreplace_file","text":"Now let's imagine we have real files like sample.rb with the following code: def good_bye message = [ \"good\" , \"bye\" ] puts message . join ( ' ' ) end And we decide to remove the message variable and put it inline with the puts . Basically, we need to find the local variable assignment, store the value in memory. Remove the assignment expression and use the value where the variable is being called. assignment = nil Fast . replace_file ( 'sample.rb' , '({ lvasgn lvar } message )' , -> ( node , _ ) { if node . type == :lvasgn assignment = node . children . last remove ( node . location . expression ) elsif node . type == :lvar replace ( node . location . expression , assignment . location . expression . source ) end } )","title":"Fast.replace_file"},{"location":"#fastast_from_filefile","text":"This method parses the code and load into a AST representation. Fast . ast_from_file ( 'sample.rb' )","title":"Fast.ast_from_File(file)"},{"location":"#fastsearch_file","text":"You can use search_file and pass the path for search for expressions inside files. Fast . search_file ( 'file.rb' , expression ) It's simple combination of Fast.ast_from_file with Fast.search .","title":"Fast.search_file"},{"location":"#fastruby_files_fromarguments","text":"You'll be probably looking for multiple ruby files, then this method fetches all internal .rb files Fast . ruby_files_from ( [ 'lib' ] ) # => [\"lib/fast.rb\"]","title":"Fast.ruby_files_from(arguments)"},{"location":"#command-line","text":"It will also inject a executable named fast and you can use it to search and find code using the concept: $ fast '(def match?)' lib/fast.rb Use -d or --debug for enable debug mode. Use --ast to output the AST instead of the original code Use --pry to jump debugging the first result with pry Use -c to search from code example Use -s to search similar code $ fast '(block (send nil it))' spec --pry And inside pry session, you can use result as the first result or results to use all occurrences found. results . map { | e | e . children [ 0 ]. children [ 2 ] } # => [s(:str, \"parses ... as Find\"), # s(:str, \"parses $ as Capture\"), # s(:str, \"parses quoted values as strings\"), # s(:str, \"parses {} as Any\"), # s(:str, \"parses [] as All\"), ...] Getting all it blocks without description: $ fast '(block (send nil it (nil)) (args ) (!str)) ) )' spec # spec/fast_spec.rb:166 it { expect ( described_class ) . to be_match ( s ( :int , 1 ), '(...)' ) } # spec/fast_spec.rb:167 it { expect ( described_class ) . to be_match ( s ( :int , 1 ), '(_ _)' ) } # spec/fast_spec.rb:168 it { expect ( described_class ) . to be_match ( code [ '\"string\"' ] , '(str \"string\")' ) } # ... more results","title":"Command line"},{"location":"#fastexperiment","text":"You can define experiments and build experimental research to improve some code in an automated way. Let's create an experiment to try to remove before or after blocks and run specs. If the spec pass without need the hook, the hook is useless. Fast . experiment ( \"RSpec/RemoveUselessBeforeAfterHook\" ) do lookup 'spec' search \"(block (send nil {before after}))\" edit { | node | remove ( node . loc . expression ) } policy { | new_file | system ( \"bin/spring rspec --fail-fast #{ new_file } \" ) } end In the lookup you can pass files or folders. The search contains the expression you want to match With edit block you can apply the code change And the policy is executed to check if the current change is valuable If the file contains multiple before or after blocks, each removal will occur independently and the successfull removals will be combined as a secondary change. The process repeates until find all possible combinations. See more examples in experiments folder. To run multiple experiments, use fast-experiment runner: fast-experiment <experiment-names> <files-or-folders> You can limit experiments or file escope: fast-experiment RSpec/RemoveUselessBeforeAfterHook spec/models/**/*_spec.rb","title":"Fast.experiment"},{"location":"experiments/","text":"Experiments \u00b6 Experiments allow us to play with AST and do some code transformation, execute some code and continue combining successful transformations. The major idea is try a new approach without any promise and if it works continue transforming the code. Replace FactoryBot#create with build_stubbed . \u00b6 Let's look into the following spec example: describe \"my spec\" do let ( :user ) { create ( :user ) } let ( :address ) { create ( :address ) } # ... end Let's say we're amazed with FactoryBot#build_stubbed and want to build a small bot to make the changes in a entire code base. Skip some database touches while testing huge test suites are always a good idea. First we can hunt for the cases we want to find: $ ruby-parse -e \"create(:user)\" (send nil :create (sym :user)) Using fast in the command line to see real examples in the spec folder: $ fast \"(send nil create)\" spec If you don't have a real project but want to test, just create a sample ruby file with the code example above. Running it in a big codebase will probably find a few examples of blocks. The next step is build a replacement of each independent occurrence to use build_stubbed instead of create and combine the successful ones, run again and combine again, until try all kind of successful replacements combined. Considering we have the following code in sample_spec.rb : describe \"my spec\" do let ( :user ) { create ( :user ) } let ( :address ) { create ( :address ) } # ... end Let's create the experiment that will contain the nodes that are target to be executed and what we want to do when we find the node. experiment = Fast . experiment ( 'RSpec/ReplaceCreateWithBuildStubbed' ) do search '(send nil create)' edit { | node | replace ( node . loc . selector , 'build_stubbed' ) } end If we use Fast.replace_file it will replace all occurrences in the same run and that's one of the motivations behind create the ExperimentFile class. Executing a partial replacement of the first occurrence: experiment_file = Fast :: ExperimentFile . new ( 'sample_spec.rb' , experiment ) } puts experiment_file . partial_replace ( 1 ) The command will output the following code: describe \"my spec\" do let ( :user ) { build_stubbed ( :user ) } let ( :address ) { create ( :address ) } # ... end Remove useless before block \u00b6 Imagine the following code sample: describe \"my spec\" do before { create ( :user ) } # ... after { User . delete_all } end And now, we can define an experiment that removes the entire code block and run the experimental specs. experiment = Fast . experiment ( 'RSpec/RemoveUselessBeforeAfterHook' ) do lookup 'spec' search '(block (send nil {before after}))' edit { | node | remove ( node . loc . expression ) } policy { | new_file | system ( \"bin/spring rspec --fail-fast #{ new_file } \" ) } end To run the experiment you can simply say: experiment . run Or drop the code into experiments folder and use the fast-experiment command line tool. $ fast-experiment RSpec/RemoveUselessBeforeAfterHook spec","title":"Experiments"},{"location":"experiments/#experiments","text":"Experiments allow us to play with AST and do some code transformation, execute some code and continue combining successful transformations. The major idea is try a new approach without any promise and if it works continue transforming the code.","title":"Experiments"},{"location":"experiments/#replace-factorybotcreate-with-build_stubbed","text":"Let's look into the following spec example: describe \"my spec\" do let ( :user ) { create ( :user ) } let ( :address ) { create ( :address ) } # ... end Let's say we're amazed with FactoryBot#build_stubbed and want to build a small bot to make the changes in a entire code base. Skip some database touches while testing huge test suites are always a good idea. First we can hunt for the cases we want to find: $ ruby-parse -e \"create(:user)\" (send nil :create (sym :user)) Using fast in the command line to see real examples in the spec folder: $ fast \"(send nil create)\" spec If you don't have a real project but want to test, just create a sample ruby file with the code example above. Running it in a big codebase will probably find a few examples of blocks. The next step is build a replacement of each independent occurrence to use build_stubbed instead of create and combine the successful ones, run again and combine again, until try all kind of successful replacements combined. Considering we have the following code in sample_spec.rb : describe \"my spec\" do let ( :user ) { create ( :user ) } let ( :address ) { create ( :address ) } # ... end Let's create the experiment that will contain the nodes that are target to be executed and what we want to do when we find the node. experiment = Fast . experiment ( 'RSpec/ReplaceCreateWithBuildStubbed' ) do search '(send nil create)' edit { | node | replace ( node . loc . selector , 'build_stubbed' ) } end If we use Fast.replace_file it will replace all occurrences in the same run and that's one of the motivations behind create the ExperimentFile class. Executing a partial replacement of the first occurrence: experiment_file = Fast :: ExperimentFile . new ( 'sample_spec.rb' , experiment ) } puts experiment_file . partial_replace ( 1 ) The command will output the following code: describe \"my spec\" do let ( :user ) { build_stubbed ( :user ) } let ( :address ) { create ( :address ) } # ... end","title":"Replace FactoryBot#create with build_stubbed."},{"location":"experiments/#remove-useless-before-block","text":"Imagine the following code sample: describe \"my spec\" do before { create ( :user ) } # ... after { User . delete_all } end And now, we can define an experiment that removes the entire code block and run the experimental specs. experiment = Fast . experiment ( 'RSpec/RemoveUselessBeforeAfterHook' ) do lookup 'spec' search '(block (send nil {before after}))' edit { | node | remove ( node . loc . expression ) } policy { | new_file | system ( \"bin/spring rspec --fail-fast #{ new_file } \" ) } end To run the experiment you can simply say: experiment . run Or drop the code into experiments folder and use the fast-experiment command line tool. $ fast-experiment RSpec/RemoveUselessBeforeAfterHook spec","title":"Remove useless before block"},{"location":"similarity_tutorial/","text":"Research for code similarity \u00b6 This is a small tutorial to explore code similarity. The major idea is register all expression styles and see if we can find some similarity between the structures. First we need to create a function that can analyze AST nodes and extract a pattern from the expression. The expression needs to generalize final node values and recursively build a pattern that can be used as a search expression. def expression_from ( node ) case node when Parser :: AST :: Node if node . children . any? children_expression = node . children . map ( & method ( :expression_from )) . join ( ' ' ) \"( #{ node . type } #{ children_expression } )\" else \"( #{ node . type } )\" end when nil , 'nil' 'nil' when Symbol , String , Integer '_' when Array , Hash '...' else node end end The pattern generated only flexibilize the search allowing us to group similar nodes. Example: expression_from ( code [ '1' ] ) # =>'(int _)' expression_from ( code [ 'nil' ] ) # =>'(nil)' expression_from ( code [ 'a = 1' ] ) # =>'(lvasgn _ (int _))' expression_from ( code [ 'def name; person.name end' ] ) # =>'(def _ (args) (send (send nil _) _))' The current method can translate all kind of expressions and the next step is observe some specific node types and try to group the similarities using the pattern generated. Fast . search_file ( 'lib/fast.rb' , 'class' ) Capturing the constant name and filtering only for symbols is easy and we can see that we have a few classes defined in the the same file. Fast . search_file ( '(class (const nil $_))' , 'lib/fast.rb' ) . grep ( Symbol ) => [ :Rewriter , :ExpressionParser , :Find , :FindString , :FindWithCapture , :Capture , :Parent , :Any , :All , :Not , :Maybe , :Matcher , :Experiment , :ExperimentFile ] The idea of this inspecton is build a proof of concept to show the similarity of matcher classes because they only define a match? method. patterns = Fast . search_file ( 'class' , 'lib/fast.rb' ) . map { | n | Fast . expression_from ( n )} A simple comparison between the patterns size versus .uniq.size can proof if the idea will work. patterns . size == patterns . uniq . size It does not work for the matcher cases but we can go deeper and analyze all files required by bundler. similarities = {} Gem . find_files ( '*.rb' ) . each do | file | Fast . search_file ( '' , file ) . map do | n | key = Fast . expression_from ( n ) similarities [ key ] ||= Set . new similarities [ key ] << file end end similarities . delete_if { | k , v | v . size < 2 } The similarities found are the following: { \"(class (const nil _) (const nil _) nil)\" => #<Set: {\"/Users/jonatasdp/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/parallel-1.12.1/lib/parallel.rb\", \"/Users/jonatasdp/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/method_source-0.9.0/lib/method_source.rb\" , \"/Users/jonatasdp/.rbenv/versions/2.5.1/lib/ruby/2.5.0/rdoc.rb\" , \"/Users/jonatasdp/.rbenv/versions/2.5.1/lib/ruby/2.5.0/irb.rb\" , \"/Users/jonatasdp/.rbenv/versions/2.5.1/lib/ruby/2.5.0/tsort.rb\" } > , \"(class (const nil _) nil nil)\" => #<Set: {\"/Users/jonatasdp/.rbenv/versions/2.5.1/lib/ruby/2.5.0/ripper.rb\", \"/Users/jonatasdp/.rbenv/versions/2.5.1/lib/ruby/2.5.0/cgi.rb\"}>} And now we can test the expression using the command line tool through the files and observe the similarity: \u22ca> ~ fast \"(class (const nil _) (const nil _) nil)\" /Users/jonatasdp/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/parallel-1.12.1/lib/parallel.rb /Users/jonatasdp/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/method_source-0.9.0/lib/method_source.rb /Users/jonatasdp/.rbenv/versions/2.5.1/lib/ruby/2.5.0/rdoc.rb /Users/jonatasdp/.rbenv/versions/2.5.1/lib/ruby/2.5.0/irb.rb /Users/jonatasdp/.rbenv/versions/2.5.1/lib/ruby/2.5.0/tsort.rb Output: # /Users/jonatasdp/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/parallel-1.12.1/lib/parallel.rb:8 class DeadWorker < StandardError end # /Users/jonatasdp/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/parallel-1.12.1/lib/parallel.rb:11 class Break < StandardError end # /Users/jonatasdp/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/parallel-1.12.1/lib/parallel.rb:14 class Kill < StandardError end # /Users/jonatasdp/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/method_source-0.9.0/lib/method_source.rb:16 class SourceNotFoundError < StandardError ; end # /Users/jonatasdp/.rbenv/versions/2.5.1/lib/ruby/2.5.0/rdoc.rb:63 class Error < RuntimeError ; end # /Users/jonatasdp/.rbenv/versions/2.5.1/lib/ruby/2.5.0/irb.rb:338 class Abort < Exception ; end # /Users/jonatasdp/.rbenv/versions/2.5.1/lib/ruby/2.5.0/tsort.rb:125 class Cyclic < StandardError end It works and now we can create a method to do what the command line tool did, grouping the patterns and inspecting the occurrences. def similarities . show pattern files = self [ pattern ] files . each do | file | nodes = Fast . search_file ( pattern , file ) nodes . each do | result | Fast . report ( result , file : file ) end end end And calling the method exploring some \"if\" similarities, it prints the following results: similarities . show \"(if (send (const nil _) _ (lvar _)) nil (return (false)))\" # /Users/jonatasdp/.rbenv/versions/2.5.1/lib/ruby/2.5.0/resolv.rb:1248 return false unless Name === other # /Users/jonatasdp/.rbenv/versions/2.5.1/lib/ruby/2.5.0/fileutils.rb:138 return false unless File . exist? ( new ) # /Users/jonatasdp/.rbenv/versions/2.5.1/lib/ruby/2.5.0/matrix.rb:1862 return false unless Vector === other","title":"Code Similarity"},{"location":"similarity_tutorial/#research-for-code-similarity","text":"This is a small tutorial to explore code similarity. The major idea is register all expression styles and see if we can find some similarity between the structures. First we need to create a function that can analyze AST nodes and extract a pattern from the expression. The expression needs to generalize final node values and recursively build a pattern that can be used as a search expression. def expression_from ( node ) case node when Parser :: AST :: Node if node . children . any? children_expression = node . children . map ( & method ( :expression_from )) . join ( ' ' ) \"( #{ node . type } #{ children_expression } )\" else \"( #{ node . type } )\" end when nil , 'nil' 'nil' when Symbol , String , Integer '_' when Array , Hash '...' else node end end The pattern generated only flexibilize the search allowing us to group similar nodes. Example: expression_from ( code [ '1' ] ) # =>'(int _)' expression_from ( code [ 'nil' ] ) # =>'(nil)' expression_from ( code [ 'a = 1' ] ) # =>'(lvasgn _ (int _))' expression_from ( code [ 'def name; person.name end' ] ) # =>'(def _ (args) (send (send nil _) _))' The current method can translate all kind of expressions and the next step is observe some specific node types and try to group the similarities using the pattern generated. Fast . search_file ( 'lib/fast.rb' , 'class' ) Capturing the constant name and filtering only for symbols is easy and we can see that we have a few classes defined in the the same file. Fast . search_file ( '(class (const nil $_))' , 'lib/fast.rb' ) . grep ( Symbol ) => [ :Rewriter , :ExpressionParser , :Find , :FindString , :FindWithCapture , :Capture , :Parent , :Any , :All , :Not , :Maybe , :Matcher , :Experiment , :ExperimentFile ] The idea of this inspecton is build a proof of concept to show the similarity of matcher classes because they only define a match? method. patterns = Fast . search_file ( 'class' , 'lib/fast.rb' ) . map { | n | Fast . expression_from ( n )} A simple comparison between the patterns size versus .uniq.size can proof if the idea will work. patterns . size == patterns . uniq . size It does not work for the matcher cases but we can go deeper and analyze all files required by bundler. similarities = {} Gem . find_files ( '*.rb' ) . each do | file | Fast . search_file ( '' , file ) . map do | n | key = Fast . expression_from ( n ) similarities [ key ] ||= Set . new similarities [ key ] << file end end similarities . delete_if { | k , v | v . size < 2 } The similarities found are the following: { \"(class (const nil _) (const nil _) nil)\" => #<Set: {\"/Users/jonatasdp/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/parallel-1.12.1/lib/parallel.rb\", \"/Users/jonatasdp/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/method_source-0.9.0/lib/method_source.rb\" , \"/Users/jonatasdp/.rbenv/versions/2.5.1/lib/ruby/2.5.0/rdoc.rb\" , \"/Users/jonatasdp/.rbenv/versions/2.5.1/lib/ruby/2.5.0/irb.rb\" , \"/Users/jonatasdp/.rbenv/versions/2.5.1/lib/ruby/2.5.0/tsort.rb\" } > , \"(class (const nil _) nil nil)\" => #<Set: {\"/Users/jonatasdp/.rbenv/versions/2.5.1/lib/ruby/2.5.0/ripper.rb\", \"/Users/jonatasdp/.rbenv/versions/2.5.1/lib/ruby/2.5.0/cgi.rb\"}>} And now we can test the expression using the command line tool through the files and observe the similarity: \u22ca> ~ fast \"(class (const nil _) (const nil _) nil)\" /Users/jonatasdp/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/parallel-1.12.1/lib/parallel.rb /Users/jonatasdp/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/method_source-0.9.0/lib/method_source.rb /Users/jonatasdp/.rbenv/versions/2.5.1/lib/ruby/2.5.0/rdoc.rb /Users/jonatasdp/.rbenv/versions/2.5.1/lib/ruby/2.5.0/irb.rb /Users/jonatasdp/.rbenv/versions/2.5.1/lib/ruby/2.5.0/tsort.rb Output: # /Users/jonatasdp/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/parallel-1.12.1/lib/parallel.rb:8 class DeadWorker < StandardError end # /Users/jonatasdp/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/parallel-1.12.1/lib/parallel.rb:11 class Break < StandardError end # /Users/jonatasdp/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/parallel-1.12.1/lib/parallel.rb:14 class Kill < StandardError end # /Users/jonatasdp/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/method_source-0.9.0/lib/method_source.rb:16 class SourceNotFoundError < StandardError ; end # /Users/jonatasdp/.rbenv/versions/2.5.1/lib/ruby/2.5.0/rdoc.rb:63 class Error < RuntimeError ; end # /Users/jonatasdp/.rbenv/versions/2.5.1/lib/ruby/2.5.0/irb.rb:338 class Abort < Exception ; end # /Users/jonatasdp/.rbenv/versions/2.5.1/lib/ruby/2.5.0/tsort.rb:125 class Cyclic < StandardError end It works and now we can create a method to do what the command line tool did, grouping the patterns and inspecting the occurrences. def similarities . show pattern files = self [ pattern ] files . each do | file | nodes = Fast . search_file ( pattern , file ) nodes . each do | result | Fast . report ( result , file : file ) end end end And calling the method exploring some \"if\" similarities, it prints the following results: similarities . show \"(if (send (const nil _) _ (lvar _)) nil (return (false)))\" # /Users/jonatasdp/.rbenv/versions/2.5.1/lib/ruby/2.5.0/resolv.rb:1248 return false unless Name === other # /Users/jonatasdp/.rbenv/versions/2.5.1/lib/ruby/2.5.0/fileutils.rb:138 return false unless File . exist? ( new ) # /Users/jonatasdp/.rbenv/versions/2.5.1/lib/ruby/2.5.0/matrix.rb:1862 return false unless Vector === other","title":"Research for code similarity"},{"location":"syntax/","text":"Syntax \u00b6 The syntax is inspired on RuboCop Node Pattern . You can find a great tutorial about RuboCop node pattern in the official documentation . The basic elemements are: () to represent a node search {} is for any matches like union conditions with or operator [] is for all matches like intersect conditions with and operator $ is for capture current expression _ is something not nil nil matches exactly nil ... is a node with children ^ is to get the parent node of an expression ? is for maybe \\1 to use the first previous captured element \"\" surround the value with double quotes to match literal strings Code example \u00b6 Let's consider the following example.rb code example: class Example ANSWER = 42 def magic rand ( ANSWER ) end def duplicate ( value ) value * 2 end end Looking the AST representation we have: $ ruby-parse example.rb (class (const nil :Example) nil (begin (casgn nil :ANSWER (int 42)) (def :magic (args) (send nil :rand (const nil :ANSWER))) (def :duplicate (args (arg :value)) (send (lvar :value) :* (int 2))))) Now, let's explore all details of the current AST, combining with the syntax operators. Fast works with a single word that will be the node type. A simple search of def nodes can be done and will also print the code. $ fast def example.rb # example.rb:3 def magic rand ( ANSWER ) end or check the casgn that will show constant assignments: $ fast casgn example.rb # example.rb:2 ANSWER = 42 () to represent a node search \u00b6 To specify details about a node, the ( means navigate deeply into a node and go deep into the expression. $ fast '(casgn' example.rb # example.rb:2 ANSWER = 42 Fast matcher never checks the end of the expression and close parens are not necessary. We keep them for the sake of specify more node details but the expression works with incomplete parens. $ fast '(casgn)' example.rb # example.rb:2 ANSWER = 42 Closing extra params also don't have a side effect. $ fast '(casgn))' example.rb # example.rb:2 ANSWER = 42 It also automatically flat parens case you put more levels in the beginning. $ fast '((casgn))' example.rb # example.rb:2 ANSWER = 42 For checking AST details while doing some search, you can use --ast in the command line for printing the AST instead of the code: $ fast '((casgn ' example.rb --ast # example.rb:2 ( casgn nil :ANSWER ( int 42 )) _ is something not nil \u00b6 Let's enhance our current expression and specify that we're looking for constant assignments of integers ignoring values and constant names replacing with _ . $ fast '(casgn nil _ (int _))' example.rb # example.rb:2 ANSWER = 42 Keep in mind that _ means not nil and (casgn _ _ (int _)) would not match. Let's search for integer nodes: $ fast int example.rb # example.rb:2 42 # example.rb:7 2 The current search show the nodes but they are not so useful without understand the expression in their context. We need to check their parent . ^ is to get the parent node of an expression \u00b6 By default, Parser::AST::Node does not have access to parent and for accessing it you can say ^ for reaching the parent. $ fast '^int' example.rb # example.rb:2 ANSWER = 42 # example.rb:7 value * 2 And using it multiple times will make the node match from levels up: $ fast '^^int' example.rb # example.rb:2 ANSWER = 42 def magic rand ( ANSWER ) end def duplicate ( value ) value * 2 end [] join conditions \u00b6 Let's hunt for integer nodes that the parent is also a method: $ fast '[ ^^int def ]' example.rb The match will filter only nodes that matches all internal expressions. # example.rb:6 def duplicate ( value ) value * 2 end The expression is matching nodes that have a integer granchild and also with type def . ... is a node with children \u00b6 Looking the method representation we have: $ fast def example.rb --ast # example.rb:3 ( def :magic ( args ) ( send nil :rand ( const nil :ANSWER ))) # example.rb:6 ( def :duplicate ( args ( arg :value )) ( send ( lvar :value ) :* ( int 2 ))) And if we want to delimit only methods with arguments: $ fast '(def _ ...)' example.rb # example.rb:6 def duplicate ( value ) value * 2 end If we use (def _ _) instead it will match both methods because (args) does not have children but is not nil. $ is for capture current expression \u00b6 Now, let's say we want to extract some method name from current classes. In such case we don't want to have the node definition but only return the node name. # example.rb:2 def magic rand ( ANSWER ) end # example.rb: magic # example.rb:9 def duplicate ( value ) value * 2 end # example.rb: duplicate One extra method name was printed because of $ is capturing the element. fast --pry \u00b6 Let's use the --pry for inspecting the results. $ fast '(def $_)' example.rb --pry It will open pry with access to result as the first result and results with all matching results. From: /Users/jonatasdp/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/ffast-0.0.2/bin/fast @ line 60 : 55: 56: results.each do |result| 57: next if result.nil? || result == [] 58: if pry 59: require 'pry' => 60: binding.pry # rubocop:disable Lint/Debugger 61: else 62: Fast.report(result, file: file, show_sexp: show_sexp) 63: end 64: end 65: end Inspecting the results you can see that they are mixing AST nodes and the captures. [ 1 ] pry ( main ) > results => [ s ( :def , :magic , s ( :args ), s ( :send , nil , :rand , s ( :const , nil , :ANSWER ))), :magic , s ( :def , :duplicate , s ( :args , s ( :arg , :value )), s ( :send , s ( :lvar , :value ), :* , s ( :int , 2 ))), :duplicate ] We can filter the captures to make it easy to analyze. [ 2 ] pry ( main ) > results . grep ( Symbol ) => [ :magic , :duplicate ] nil matches exactly nil \u00b6 Nil is used in the code as a node type but parser gem also represents empty spaces in expressions with nil. Example, a method call from Kernel is a send from nil calling the method while I can also send a method call from a class. $ ruby-parse -e 'method' (send nil :method) And a method from a object will have the nested target not nil. $ ruby-parse -e 'object.method' (send (send nil :object) :method) Let's build a serch for any calls from nil : $ fast '(_ nil _)' example.rb # example.rb:3 Example # example.rb:4 ANSWER = 42 # example.rb:6 rand ( ANSWER ) Double check the expressions that have matched printing the AST: $ fast '(_ nil _)' example.rb --ast # example.rb:3 ( const nil :Example ) # example.rb:4 ( casgn nil :ANSWER ( int 42 )) # example.rb:6 ( send nil :rand ( const nil :ANSWER )) {} is for any matches like union conditions with or operator \u00b6 Let's say we to add check all occurrencies of the constant ANSWER . We'll need to get both casgn and const node types. For such cases we can surround the expressions with {} and it will return if the node matches with any of the internal expressions. $ fast '({casgn const} nil ANSWER)' example.rb # example.rb:4 ANSWER = 42 # example.rb:6 ANSWER ? is for maybe \u00b6 \\1 to use the first previous captured element \u00b6 \"\" surround the value with double quotes to match literal strings \u00b6","title":"Syntax"},{"location":"syntax/#syntax","text":"The syntax is inspired on RuboCop Node Pattern . You can find a great tutorial about RuboCop node pattern in the official documentation . The basic elemements are: () to represent a node search {} is for any matches like union conditions with or operator [] is for all matches like intersect conditions with and operator $ is for capture current expression _ is something not nil nil matches exactly nil ... is a node with children ^ is to get the parent node of an expression ? is for maybe \\1 to use the first previous captured element \"\" surround the value with double quotes to match literal strings","title":"Syntax"},{"location":"syntax/#code-example","text":"Let's consider the following example.rb code example: class Example ANSWER = 42 def magic rand ( ANSWER ) end def duplicate ( value ) value * 2 end end Looking the AST representation we have: $ ruby-parse example.rb (class (const nil :Example) nil (begin (casgn nil :ANSWER (int 42)) (def :magic (args) (send nil :rand (const nil :ANSWER))) (def :duplicate (args (arg :value)) (send (lvar :value) :* (int 2))))) Now, let's explore all details of the current AST, combining with the syntax operators. Fast works with a single word that will be the node type. A simple search of def nodes can be done and will also print the code. $ fast def example.rb # example.rb:3 def magic rand ( ANSWER ) end or check the casgn that will show constant assignments: $ fast casgn example.rb # example.rb:2 ANSWER = 42","title":"Code example"},{"location":"syntax/#to-represent-a-node-search","text":"To specify details about a node, the ( means navigate deeply into a node and go deep into the expression. $ fast '(casgn' example.rb # example.rb:2 ANSWER = 42 Fast matcher never checks the end of the expression and close parens are not necessary. We keep them for the sake of specify more node details but the expression works with incomplete parens. $ fast '(casgn)' example.rb # example.rb:2 ANSWER = 42 Closing extra params also don't have a side effect. $ fast '(casgn))' example.rb # example.rb:2 ANSWER = 42 It also automatically flat parens case you put more levels in the beginning. $ fast '((casgn))' example.rb # example.rb:2 ANSWER = 42 For checking AST details while doing some search, you can use --ast in the command line for printing the AST instead of the code: $ fast '((casgn ' example.rb --ast # example.rb:2 ( casgn nil :ANSWER ( int 42 ))","title":"() to represent a node search"},{"location":"syntax/#_-is-something-not-nil","text":"Let's enhance our current expression and specify that we're looking for constant assignments of integers ignoring values and constant names replacing with _ . $ fast '(casgn nil _ (int _))' example.rb # example.rb:2 ANSWER = 42 Keep in mind that _ means not nil and (casgn _ _ (int _)) would not match. Let's search for integer nodes: $ fast int example.rb # example.rb:2 42 # example.rb:7 2 The current search show the nodes but they are not so useful without understand the expression in their context. We need to check their parent .","title":"_ is something not nil"},{"location":"syntax/#is-to-get-the-parent-node-of-an-expression","text":"By default, Parser::AST::Node does not have access to parent and for accessing it you can say ^ for reaching the parent. $ fast '^int' example.rb # example.rb:2 ANSWER = 42 # example.rb:7 value * 2 And using it multiple times will make the node match from levels up: $ fast '^^int' example.rb # example.rb:2 ANSWER = 42 def magic rand ( ANSWER ) end def duplicate ( value ) value * 2 end","title":"^ is to get the parent node of an expression"},{"location":"syntax/#join-conditions","text":"Let's hunt for integer nodes that the parent is also a method: $ fast '[ ^^int def ]' example.rb The match will filter only nodes that matches all internal expressions. # example.rb:6 def duplicate ( value ) value * 2 end The expression is matching nodes that have a integer granchild and also with type def .","title":"[] join conditions"},{"location":"syntax/#is-a-node-with-children","text":"Looking the method representation we have: $ fast def example.rb --ast # example.rb:3 ( def :magic ( args ) ( send nil :rand ( const nil :ANSWER ))) # example.rb:6 ( def :duplicate ( args ( arg :value )) ( send ( lvar :value ) :* ( int 2 ))) And if we want to delimit only methods with arguments: $ fast '(def _ ...)' example.rb # example.rb:6 def duplicate ( value ) value * 2 end If we use (def _ _) instead it will match both methods because (args) does not have children but is not nil.","title":"... is a node with children"},{"location":"syntax/#is-for-capture-current-expression","text":"Now, let's say we want to extract some method name from current classes. In such case we don't want to have the node definition but only return the node name. # example.rb:2 def magic rand ( ANSWER ) end # example.rb: magic # example.rb:9 def duplicate ( value ) value * 2 end # example.rb: duplicate One extra method name was printed because of $ is capturing the element.","title":"$ is for capture current expression"},{"location":"syntax/#fast-pry","text":"Let's use the --pry for inspecting the results. $ fast '(def $_)' example.rb --pry It will open pry with access to result as the first result and results with all matching results. From: /Users/jonatasdp/.rbenv/versions/2.5.1/lib/ruby/gems/2.5.0/gems/ffast-0.0.2/bin/fast @ line 60 : 55: 56: results.each do |result| 57: next if result.nil? || result == [] 58: if pry 59: require 'pry' => 60: binding.pry # rubocop:disable Lint/Debugger 61: else 62: Fast.report(result, file: file, show_sexp: show_sexp) 63: end 64: end 65: end Inspecting the results you can see that they are mixing AST nodes and the captures. [ 1 ] pry ( main ) > results => [ s ( :def , :magic , s ( :args ), s ( :send , nil , :rand , s ( :const , nil , :ANSWER ))), :magic , s ( :def , :duplicate , s ( :args , s ( :arg , :value )), s ( :send , s ( :lvar , :value ), :* , s ( :int , 2 ))), :duplicate ] We can filter the captures to make it easy to analyze. [ 2 ] pry ( main ) > results . grep ( Symbol ) => [ :magic , :duplicate ]","title":"fast --pry"},{"location":"syntax/#nil-matches-exactly-nil","text":"Nil is used in the code as a node type but parser gem also represents empty spaces in expressions with nil. Example, a method call from Kernel is a send from nil calling the method while I can also send a method call from a class. $ ruby-parse -e 'method' (send nil :method) And a method from a object will have the nested target not nil. $ ruby-parse -e 'object.method' (send (send nil :object) :method) Let's build a serch for any calls from nil : $ fast '(_ nil _)' example.rb # example.rb:3 Example # example.rb:4 ANSWER = 42 # example.rb:6 rand ( ANSWER ) Double check the expressions that have matched printing the AST: $ fast '(_ nil _)' example.rb --ast # example.rb:3 ( const nil :Example ) # example.rb:4 ( casgn nil :ANSWER ( int 42 )) # example.rb:6 ( send nil :rand ( const nil :ANSWER ))","title":"nil matches exactly nil"},{"location":"syntax/#is-for-any-matches-like-union-conditions-with-or-operator","text":"Let's say we to add check all occurrencies of the constant ANSWER . We'll need to get both casgn and const node types. For such cases we can surround the expressions with {} and it will return if the node matches with any of the internal expressions. $ fast '({casgn const} nil ANSWER)' example.rb # example.rb:4 ANSWER = 42 # example.rb:6 ANSWER","title":"{} is for any matches like union conditions with or operator"},{"location":"syntax/#is-for-maybe","text":"","title":"? is for maybe"},{"location":"syntax/#1-to-use-the-first-previous-captured-element","text":"","title":"\\1 to use the first previous captured element"},{"location":"syntax/#surround-the-value-with-double-quotes-to-match-literal-strings","text":"","title":"\"\" surround the value with double quotes to match literal strings"}]}